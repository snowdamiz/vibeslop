defmodule Backend.AI.ImageCache do
  @moduledoc """
  ETS-based cache for tracking AI-generated images.

  When an image is generated via our AI pipeline, its SHA256 hash is stored here.
  This allows skipping redundant NSFW moderation for AI-generated images since
  they're already constrained by content policy in the generation prompt.

  Features:
  - O(1) lookups via ETS
  - Automatic expiration (1 hour TTL)
  - Self-cleaning (5 minute cleanup interval)
  """

  use GenServer
  require Logger

  @table_name :ai_generated_images
  @ttl_ms :timer.hours(1)
  @cleanup_interval_ms :timer.minutes(5)

  # Client API

  @doc """
  Starts the ImageCache GenServer.
  """
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc """
  Marks an image as AI-generated by storing its SHA256 hash.
  """
  def mark_as_ai_generated(image_data) when is_binary(image_data) do
    hash = compute_hash(image_data)
    GenServer.cast(__MODULE__, {:mark, hash})
    :ok
  end

  @doc """
  Checks if an image was AI-generated by looking up its hash.
  """
  def is_ai_generated?(image_data) when is_binary(image_data) do
    hash = compute_hash(image_data)

    case :ets.lookup(@table_name, hash) do
      [{^hash, expires_at}] ->
        if System.monotonic_time(:millisecond) < expires_at do
          true
        else
          # Expired entry - will be cleaned up later
          false
        end

      [] ->
        false
    end
  end

  # Server callbacks

  @impl true
  def init(_opts) do
    # Create ETS table for storing image hashes
    :ets.new(@table_name, [:set, :named_table, :public, read_concurrency: true])

    # Schedule periodic cleanup
    schedule_cleanup()

    Logger.info("ImageCache started")
    {:ok, %{}}
  end

  @impl true
  def handle_cast({:mark, hash}, state) do
    expires_at = System.monotonic_time(:millisecond) + @ttl_ms
    :ets.insert(@table_name, {hash, expires_at})
    {:noreply, state}
  end

  @impl true
  def handle_info(:cleanup, state) do
    cleanup_expired()
    schedule_cleanup()
    {:noreply, state}
  end

  # Private functions

  defp compute_hash(image_data) do
    :crypto.hash(:sha256, image_data)
    |> Base.encode16(case: :lower)
  end

  defp schedule_cleanup do
    Process.send_after(self(), :cleanup, @cleanup_interval_ms)
  end

  defp cleanup_expired do
    now = System.monotonic_time(:millisecond)

    expired_count =
      :ets.foldl(
        fn {hash, expires_at}, count ->
          if now >= expires_at do
            :ets.delete(@table_name, hash)
            count + 1
          else
            count
          end
        end,
        0,
        @table_name
      )

    if expired_count > 0 do
      Logger.debug("ImageCache cleanup: removed #{expired_count} expired entries")
    end
  end
end
